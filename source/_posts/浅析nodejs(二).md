---
title: 浅析node(二)
date: 2018-2-13 10:54
tags: node
categories: node
summary_img: http://p56w6hcyq.bkt.clouddn.com/node2.jpg
---
关于node的常见知识点札记

- 同步和异步的对比【非阻塞I/O和阻塞I/O】

  异步读取文件

  异步嵌套读取文件

  同步读取文件

  异步和同步操作中，捕获错误的方式

  <!--more-->

  Node 中的模块化

  什么是程序开发中的模块及好处

  - 什么是程序开发中的模块化：把一些功能类似的代码，封装到一个单独的文件中去，这些单独抽离出来的代码文件，就能够提供各种各样好用的功能；这种通过代码功能分割文件的方式，叫做程序中的模块化；

  - 好处：保证了每个文件的功能（职能）单一；需要什么特定的功能，直接调用某一个特定的模块；对将来程序开发和维护都有好处！


  Node 中如何实现模块化

  在Node中通过三个东西实现模块化：

-   module：表示一个模块，在Node中，最常见的模块，就是一个个的JS文件！
  - require：作用是加载其他模块用的；在一个JS文件中，如何引用其他JS文件中的成员呢？就是用require
  - exports：在Node的模块中，如果这个模块需要向外暴露一些成员，供其他JS模块使用，那么，需要使用exports向外暴露这些成员！

  Node 中的模块化，主要解决的JS文件之间的相互依赖关系！

  Node 中的模块的分类

  node由三部分组成：ECMAScript + 核心API + 第三方等API

  核心模块

  - 什么是核心模块：官方，发现一些功能模块使用非常频繁，然后，官方把这些模块，编译成了二进制可执行文件，然后打包到了Node的安装包中；所以，这些核心模块就已经随着安装Node时候，被安装到了本地；
  - 如何使用核心模块
    使用require（‘核心模块的名称’）；

  第三方模块

  - 什么是第三方模块：出了官方提供的好用的核心模块之外，我们程序员发现，还有一些使用也很频繁的代码和方法，一些牛逼的团体、个人、公司，开发出了好用的模块，通过NPM官网，托管出去，供其他人下载使用的这些模块；统称为第三方模块；
  - 如何使用第三方模块
    －　通过moment这个第三方模块，来介绍如何使用一个第三方模块；
  - 第三方模块的使用方式：

  1. 先使用npm下载这个模块！【注意：在安装第三方模块的时候，安装的名字，就是你在require时候导入的名字】
  2. 使用require导入这个第三方模块！
  3. 通过官方文档，试着去使用这个第三方模块！
  4. 注意：无论是核心模块、还是第三方模块，都是通过 标识符名称来引用这个模块的！

  用户模块

  - 什么是用户模块：程序员自己定义的JS文件，统统数据用户模块！
  - 用户模块向外导出成员的两种方式：

  - 第一种方式：使用global对象，相当于浏览器中的window对象
    - 1. 全局变量污染，
    - 1. 不知道成员是从哪个模块中暴露 出去的
  - 推荐Node提供的exports

  exports 和 module.exports 的区别

  1. 通过 module.exports 可以使用 . 的形式追加属性，也可以使用 等号 直接赋值的形式导出成员；
  2. exports 只能通过 . 的形式追加属性；不能使用 等号 直接赋值的形式！
  3. 注意： 在一个 module 中，最终向外暴露的成员，以 module.exports 指向的对象为准！
  4. 在一个模块中，不要混合使用 module.exports 和 exports

  模块加载规则

  1. 优先从缓存中加载
  2. 加载核心模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载核心模块！
  3. 自己的模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载用户模块！

  - 用户模块的查找规则：

      用户模块的查找规则：
      如果不写后缀名，则先严格按照给定的文件名去查找模块并加载执行；
      index   ->  index.js  ->   index.json    ->  index.node

  1. 第三方模块查找规则：
     1. node首先，查看项目根目录中有没有 node_modules 文件夹
     2. 查找 node_modules 文件夹中，有没有和第三方模块名称一致的文件夹
     3. 在模块对应的文件夹中，查找有没有 package.json 这个文件
     4. 在 package.json 文件中，查找有没有 main 属性
     5. 如果有 main 属性，并且 main 属性指向的路径存在，那么就尝试加载这个路径指定的文件！
     6. 如果 package.json 文件中，没有 main 属性，或者 main 属性指向的路径不存在，或者没有package.json 文件， 那么，Node尝试加载 模块根目录中 index 相关文件：index.js -> index.json -> index.node
     7. 如果在node_modules文件夹中，找不到对应的模块文件夹，或者在项目根目录中根本没有node_modules文件夹，则向上一层文件夹中去查找，查找规则同上！
     8. 如果上一层目录中也没有查找到，则再向上翻一层去查找，直到找到当前项目所在的盘符根目录为止！
     9. 如果找到了盘符根目录还找不到，则报错：cannot find module ***

  只安装部署依赖项不安装开发工具

      npm i --production

  模块化

  1. node中的模块化基于commonJS:最显著的特点所有依赖项都是同步加载的！！！
  2. commonJS由于是一个同步加载规范，所以不适合浏览器端使用；于是，浏览器端需要使用异步的模块加载机制
  3. AMD、CMD

  结合art-template模板引擎在服务器端渲染页面

  art-template官方文档

  服务端渲染和客户端渲染的对比

  博客园官网

  1. 服务器端渲染

  - 特点：Node服务器先读取模板页面，再获取要渲染的数据，然后直接在服务器端把完整的页面渲染拼接好，然后通过网络一次性的把结果发送给浏览器去显示！【注意：通过服务器端渲染，在网络中传输的是一个真正页面】
  - 优点：请求次数少，速度快，对SEO友好
  - 缺点：服务器渲染压力大【在后端可以通过缓存机制去解决】

  1. 客户端渲染

  - 特点：先访问服务器获取到模板页面，然后再通过Ajax获取要渲染的数据，拿到这两者之后，再客户端调用模板引擎，渲染得到模板字符串，然后通过JS的方式，把结果展示到页面上！【真正的页面是在客户端浏览器中怼出来的，在进行网络传输的时候，第一次传输的是模板页面，第二次传输的是数据】
  - 优点：减轻了服务器端的渲染压力
  - 缺点：请求次数多，用户体验可能没有服务器端渲染好（白屏效果）；对SEO不友好

  使用nodemon来自动重启Node服务

  1. 运行npm i nodemon -g全局安装模块
  2. 使用方式 和 node 完全一样：

  - node 要执行文件的路径
  - nodemon 要执行文件的路径

  文件列表小案例

  获取文件的属性

  在优化前, 先封装一个根据指定路径读取文件内容的方法【重点】

  将读取文件夹的方法抽离出来，同时对error进行处理【重点】

  相关文章

  1. art-template 官方文档
  2. ES6 - 模板字符串
  3. js中的数组对象排序
  4. i5ting/tocmd.npm 将MD转换为HTML